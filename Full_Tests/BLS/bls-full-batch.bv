name := bls
# number of signatures in a batch
N := 2
setting := asymmetric

# types for variables used in verification.
# all other variable types are inferred by SDL parser
BEGIN :: types
h := G1
sig := G1
g := G2
pk := G2
M := str
Mlist := list
siglist := list{G1}
delta := list{ZR} # add as a result of batch verify
dotACache := list{G1}
dotBCache := list{G1}
incorrectIndices := list
startSigNum := int
endSigNum := int
dotALoopVal := G1
dotBLoopVal := G1
END :: types

# description of key generation and signing algorithms
BEGIN :: func:keygen
input := None
 g := random(G2)
 x := random(ZR)
 pk := g^x
 sk := x
output := list{pk, sk, g}
END :: func:keygen

BEGIN :: func:sign
input := list{sk, M}
 sig := (H(M, G1))^sk
output := sig
END :: func:sign

BEGIN :: func:verify
 input := list{pk, M, sig, g}
 h := H(M, G1)
 BEGIN :: if
 if {e(h, pk) == e(sig, g)}
 output := True
 else
 output := False
 END :: if
END :: func:verify

constant := g
public :=  pk
signature :=  sig
message :=  h

# single signer
BEGIN :: count
message_count := N
public_count := one
signature_count := N
END :: count

# variables computed before each signature verification
BEGIN :: precompute
  h := H(M, G1)
END :: precompute

# individual verification check
verify := {e(h, pk) == e(sig, g)}




BEGIN :: func:batchverify
input := list{pk, Mlist, siglist, g, incorrectIndices}

BEGIN :: for
for{z:=0, N}
 delta#z := smallexp()
END :: for

BEGIN :: for
for{z :=0, N}
 BEGIN :: if
  if {(membership(pk, Mlist, siglist, g) == False)}
     output := False
 END :: if
END :: for

BEGIN :: for
for{z:=0, N}
 h := H(Mlist#z, G1)
 dotACache#z := h ^ delta#z
 dotBCache#z := siglist#z ^ delta#z
END :: for

 dividenconquer(delta, dotACache, dotBCache, 0, N, incorrectIndices, pk, Mlist, siglist, g)

 output := incorrectIndices
END ::func:batchverify


BEGIN :: func:dividenconquer
 input := list{delta, dotACache, dotBCache, startSigNum, endSigNum, incorrectIndices, pk, Mlist, siglist, g}
 
 dotALoopVal := init(G1)
 dotBLoopVal := init(G1)

BEGIN :: for
for{z:=startSigNum, endSigNum} 
 dotALoopVal := dotALoopVal * dotACache#z
 dotBLoopVal := dotBLoopVal * dotBCache#z
END :: for

BEGIN :: if
 if { e(dotALoopVal, pk) == e(dotBLoopVal, g) }
    output := True
    return := True
 else
    midwayFloat := ((endSigNum - startSigNum) / 2)
    midway := integer(midwayFloat) 
END :: if

BEGIN :: if
 if { midway == 0 } 
    addToList(incorrectIndices, startSigNum)
    output := None
 else
    midSigNum := startSigNum + midway
    dividenconquer(delta, dotACache, dotBCache, startSigNum, midway, incorrectIndices, pk, Mlist, siglist, g)
    dividenconquer(delta, dotACache, dotBCache, midSigNum, endSigNum, incorrectIndices, pk, Mlist, siglist, g)
END :: if

 output := None
END ::func:dividenconquer



BEGIN :: func:membership
 input := list{pk, Mlist, siglist, g}
 
 BEGIN :: if
  if { ismember(pk) == False }
     output := False
 END :: if

 BEGIN :: if
  if { ismember(Mlist) == False }
     output := False
 END :: if
 
 BEGIN :: if
  if { ismember(siglist) == False }
     output := False
 END :: if

 BEGIN :: if
  if { ismember(g) == False }
     output := False
 END :: if

 output := True
END :: func:membership
