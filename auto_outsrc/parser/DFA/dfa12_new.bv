name := dfa12
setting := symmetric

BEGIN :: types
M := GT
alphabet := list{str}
mpk := list
msk := list
sk := list
ct := list
Q := list{int}
Tlist := list{int}
T := list{Tlist}
Ti := list{int}
q0 := list{int}
F := list{int}
Klist := list{G1, G1, G1}
key := int
K := list{Klist}
KendList1 := list{G1}
KendList2 := list{G1}
w := list{str}
B := list{GT}
Clist := list{G1, G1}
C := list{Clist}
D := list{G1}
D#0 := G1
h := list{G1}
x := int
t := list{int}
t0 := int
t1 := int
st := int
j := int
END :: types


BEGIN :: func:setup
input := list{alphabet}
g := random(G1)
z := random(G1)
hstart := random(G1)
hend := random(G1)

A := len(alphabet)
BEGIN :: for
for{i := 0,A}
a := getString(alphabet#i)
h#a? := random(G1)
END :: for

alpha := random(ZR)
egg := (e(g,g)^alpha)
msk := (g^-alpha)
mpk := list{egg, g, z, h, hstart, hend}

output := list{mpk, msk}
END :: func:setup


BEGIN :: func:keygen
input := list{mpk, msk, Q, T, F}
mpk := expand{egg, g, z, h, hstart, hend}
#dfaM := expand{Q, S, T, q0, F}

qlen := len(Q)
BEGIN :: for
for{i := 0,qlen+1}
D#i := random(G1)
END :: for

rstart := random(ZR)
Kstart1 := (D#0 * (hstart^rstart))
Kstart2 := (g^rstart)

Tlen := len(T)
BEGIN :: for
for{i := 0,Tlen}
r := random(ZR)
t := T#i
t0 := t#0
t1 := t#1
t2 := getString(t#2)
key := hashToKey(t)

K#key := init(list)
K#key#1? := ((D#t0^-1) * (z^r))
K#key#2? := (g^r)
K#key#3? := (D#t1 * (h#t2^r))

END :: for

Flen := len(F)
BEGIN :: for
for{i := 0,Flen}
x := F#i
rx := random(ZR)
KendList1#x := (msk * (D#x * (hend^rx)))
KendList2#x := (g^rx)

END :: for

sk := list{Kstart1, Kstart2, KendList1, KendList2}
output := list{sk, K}
END :: func:keygen


BEGIN :: func:encrypt
input := list{mpk, w, M}
mpk := expand{egg, g, z, h, hstart, hend}
l := len(w)

BEGIN :: for
for{i := 0,l+1}
s#i := random(ZR)
END :: for

Cm := (M * (egg^s#l))

C#0 := init(list)
C#0#1? := (g^s#0)
C#0#2? := (hstart^s#0)

BEGIN :: for
for{i := 1,l+1}
a := getString(w#i)
C#i := init(list)
C#i#1? := (g^s#i)
C#i#2? := ((h#a^s#i) * (z^s#i-1?))
END :: for

Cend1 := (g^s#l)
Cend2 := (hend^s#l)

ct := list{Cend1, Cend2, w}
output := list{ct, Cm, C}
END :: func:encrypt



BEGIN :: func:decrypt
input := list{sk, K, ct, Cm, C}
sk := expand{Kstart1, Kstart2, KendList1, KendList2}
ct := expand{Cend1, Cend2, w}
l := len(w)

BEGIN :: if
if {accept(w) == False}
output := False
END :: if

Ti := getTransitions(w)
B#0 := (e(C#0#1?,Kstart1) * (e(C#0#2?,Kstart2)^-1))
BEGIN :: for
for{i := 1,l+1}
key := hashToKey(Ti#i)
j := (i - 1)
result0 := (e(C#j#1?,K#key#1?) * ((e(C#i#2?,K#key#2?)^-1) * e(C#i#1?,K#key#3?)))
B#i? := (B#i-1? * result0)
END :: for
x := getAcceptState(Ti)

result1 := ((e(Cend1,KendList1#x)^-1) * e(Cend2,KendList2#x))
Bend := (B#l * result1)
M := (Cm / Bend)
output := M
END :: func:decrypt
#Klist := K#key
#result0 := (e(C#j#1?,Klist#1?) * ((e(C#i#2?,Klist#2?)^-1) * e(C#i#1?,Klist#3?)))
