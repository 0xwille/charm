        H = lambda x: group.hash(('0', x), ZR)
        util = SecretShare(group, False)

name := sw05
setting := asymmetric

N := 2
secparam := 80

BEGIN :: types
END :: types

BEGIN :: func:setup
input := n
g := random(G1)
y := random(ZR)
g1 := g ^ y
g2 := random(G2)

BEGIN :: for
for{i in 0, n+1}
t#i := random(G2)
END :: for
        
pk := list{g, g1, g2, t}
mk := y
output := list{pk, mk}
END :: func:setup        


    def eval_T(self, pk, n, x):
        N = [group.init(ZR,(x + 1)) for x in range(n + 1)]        
        N_int = [(x + 1) for x in range(n + 1)]
        
        coeffs = util.recoverCoefficients(N)
        prod_result = 1
        for i in N_int:
            j = group.init(ZR, i)
            prod_result *= (pk['t'][i-1] ** coeffs[j])
        
        T = (pk['g2'] ** (x * n)) * prod_result
        return T

    def intersection_subset(self, w, wPrime, d):
        S = []
        for i in range(len(w)):
            for j in range(len(wPrime)):
                if(w[i] == wPrime[j]):
                    S.append(w[i])

        if(len(S) < d):
            assert False, "Cannot decrypt.  w and w' do not have enough attributes in common."

        S_sub  = [S[k] for k in range(d)]
        return S_sub
    
    def extract(self, mk, ID, pk, dOver, n):
        w_hash = [H(x) for x in ID] # assumes ID is a list

        r = group.random(ZR)
        #a d-1 degree polynomial q is generated such that q(0) = y
        q = [group.random(ZR) for x in range(dOver)]
        q[0] = mk['y']
        shares = util.genShares(mk['y'], dOver, n, q, w_hash)
        D = {}
        d = {}
        for i in w_hash:       
            j = w_hash.index(i)
            D[i] = (pk['g2'] ** shares[j][1]) * (self.eval_T(pk, n, i) ** r)
            d[i] = pk['g'] ** r

        return (w_hash, { 'D':D, 'd':d })

    def encrypt(self, pk, w_prime, M, n):
        '''       
        Encryption with the public key, Wprime and the message M in G2
        '''
        w_prime_hash = [H(x) for x in w_prime]
        s = group.random(ZR)

        Eprime = M * (pair(pk['g1'], pk['g2']) ** s)
        Eprimeprime = pk['g'] ** s
        
        E = {}
        for i in w_prime_hash:
            E[i] = self.eval_T(pk, n, i) ** s

        return { 'wPrime':w_prime_hash, 'Eprime':Eprime, 'Eprimeprime':Eprimeprime,'E':E}

    def decrypt(self, pk, sk, CT, w, d):
        '''dID must have an intersection overlap of at least d with Wprime to decrypt
        '''
        S = self.intersection_subset(w, CT['wPrime'], d)
        #print("S :=", S)
        coeffs = util.recoverCoefficients(S)
        prod = 1
        for i in S:
            prod *= (pair(sk['d'][i], CT['E'][i]) / pair(CT['Eprimeprime'], sk['D'][i])) ** coeffs[i]
            
        return CT['Eprime'] * prod
