name := sw05
setting := asymmetric

N := 2
secparam := 80

BEGIN :: types
END :: types

BEGIN :: func:setup
input := n
g := random(G1)
y := random(ZR)
g1 := g ^ y
g2 := random(G2)

BEGIN :: for
for{i := 0, n+1}
t#i := random(G2)
END :: for
        
dummyVar := random(ZR)

pk := list{g, g1, g2, t}
mk := list{y, dummyVar}
output := list{pk, mk}
END :: func:setup        

BEGIN :: func:evalT
input := list{pk, n, x}
BEGIN :: for
for{i := 0, n+1}
N#i := init(i+1)
Nint#i := i + 1
END :: for

coeffs := recoverCoefficients(N)
prodResult := init(1)
lenNint := len(Nint)
BEGIN :: for
for{i := 0, lenNint}
loopVar := Nint#i
j = init(i)
prodResult := prodResult * (pk#3#i-1? ^ coeffs[j])
END :: for

T := (pk#2 ^ (x * n)) * prodResult
output := T
END :: func:evalT

BEGIN :: func:extract
input := list{mk, ID, pk, dOver, n}
lenID := len(ID)
BEGIN :: for
for{i := 0, lenID}
loopVar := ID#i
wHash#i := H(loopVar, ZR)
END :: for

r := random(ZR)

BEGIN :: for
for {i := 0, dOver}
q#i := random(ZR)
END :: for

q#0 := mk#0
shares := genShares(mk#0, dOver, n, q, wHash)

wHashLen := len(wHash)
BEGIN :: for
for {i := 0, wHashLen}
loopVar := wHash#i
D#loopVar := (pk#2 ^ shares#i#1) * (evalT(pk, n, loopVar) ^ r)
d#loopVar := pk#0 ^ r
END :: for

output := list{wHash, D, d}
END :: func:extract

BEGIN :: func:encrypt
input := list{pk, wPrime, M, n}
wPrimeLen := len(wPrime)
BEGIN :: for
for {i := 0, wPrimeLen}
loopVar := wPrime#i
wPrimeHash#i := H(loopVar, ZR)
END :: for

s := random(ZR)

Eprime := M * (e(pk#1, pk#2) ^ s)
Eprimeprime := pk#0 ^ s

wPrimeHashLen := len(wPrimeHash)
BEGIN :: for
for {i := 0, wPrimeHashLen}
loopVar := wPrimeHash#i
E#i := evalT(pk, n, loopVar) ^ s
END :: for
        
output := list{wPrimeHash, Eprime, Eprimeprime, E}
END :: func:encrypt

BEGIN :: func:decrypt
input := list{pk, sk, CT, w, d}
S := intersection_subset(w, CT#0, d)
coeffs := recoverCoefficients(S)
prod := init(1)
SLen := len(S)
BEGIN :: for
for {i := 0, SLen}
loopVar := S#i
prod := prod * (e(sk#2#loopVar, CT#3#loopVar) / e(CT#2, sk#1#loopVar)) ^ coeffs#loopVar
END :: for

M := CT#1 * prod
output := M
END :: func:decrypt
