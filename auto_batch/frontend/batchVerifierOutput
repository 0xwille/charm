['bls.bv']
types  => {'M': 'str', 'h': 'G1', 'sig': 'G1', 'g': 'G2', 'pk': 'G2'}
constant  => ['g', 'pk']
variables => {'g': 'G2', 'h': 'G1', 'M': 'str', 'N': '100', 'sig': 'G1', 'pk': 'G2'}
metadata => {'N': '100'}
batch algorithm => ['2', '3']

VERIFY EQUATION => verify := e(h,pk) == e(sig,g)

Stage A: Combined Equation => verify := (prod{j := 1,N} on e(h_j,pk)) == (prod{j := 1,N} on e(sig_j,g))

Stage B: Small Exp Test => verify := (prod{j := 1,N} on e(h_j,pk)^delta_j) == (prod{j := 1,N} on e(sig_j,g)^delta_j) 

Rule 2: Left := Move 'delta_j' exponent into the pairing. Left := Move 'delta_j' exponent into the pairing.  

Applying technique 2 => : verify := (prod{j := 1,N} on e(h_j^delta_j,pk)) == (prod{j := 1,N} on e(sig_j^delta_j,g)) 

Rule 3: common 1st (left) node appears, so can reduce n pairings to 1. common 1st (left) node appears, so can reduce n pairings to 1.  

Applying technique 3 => : verify := e((prod{j := 1,N} on h_j^delta_j),pk) == e((prod{j := 1,N} on sig_j^delta_j),g) 

Instances found => {'sig_j': {'delta_j': 1}, 'h_j': {'delta_j': 1}} 

Final batch eq: e((prod{b := 1,N} on h_b^delta_b),pk%0) == e((prod{b := 1,N} on sig_b^delta_b),pk%1)
Individual verif eq => e(h,pk) == e(sig,g) 

Result N = 100 : 28.8462078
Result N = 100 : 2.0922772
Threshold:  2
Dot prod => {'start': '1', 'list': [<batchlang.BinaryNode object at 0x105091890>, <batchlang.BinaryNode object at 0x105091250>], 'stop': 'N', 'dict': {<batchlang.BinaryNode object at 0x105091890>: <batchlang.BinaryNode object at 0x105074650>, <batchlang.BinaryNode object at 0x105091250>: <batchlang.BinaryNode object at 0x105067890>}, 'index': 'j'}
<====	PREP FOR CODE GEN	====>

Final version => e(dotA,pk%0) == e(dotB,pk%1) 

Compute:  dotA := (prod{b := 1,N} on h_b^delta_b)
Compute:  dotB := (prod{b := 1,N} on sig_b^delta_b)
Precompute: h := H(M,G1)
Precompute: delta := for{j := 1, N} do prng_j
dotA := G1
dotB := G1
