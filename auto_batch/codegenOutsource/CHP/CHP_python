from charm.toolbox.pairinggroup import *
from charm.core.engine.util import *
from charm.core.math.integer import randomBits

group = None

N = 2

secparam = 80

a = {}
b = {}
h = {}

def setup():

    input = [None]
    g2 = group.random(G2)
    output = g2
    return output

def keygen(g2):

    input = [g2]
    alpha = group.random(ZR)
    sk = alpha
    pk = (g2 ** alpha)
    output = (pk, sk)
    return output

def sign(pk, sk, M, t1, t2, t3):
    global a
    global b
    global h

    input = [pk, sk, M, t1, t2, t3]
    a = group.hash(t1, G1)
    h = group.hash(t2, G1)
    b = group.hash((M, t3), ZR)
    sig = ((a ** sk) * (h ** (sk * b)))
    output = sig
    return output

def verify(pk, g2, sig, M, t1, t2, t3):
    global a
    global b
    global h

    input = [pk, g2, sig, M, t1, t2, t3]
    a = group.hash(t1, G1)
    h = group.hash(t2, G1)
    b = group.hash((M, t3), ZR)
    if ( ( (pair(sig, g2)) == ((pair(a, pk) * (pair(h, pk) ** b))) ) ):
        output = True
    else:
        output = False
    return output

def membership(g2, pklist, M, t1list, t2list, t3list, siglist):

    input = [g2, pklist, M, t1list, t2list, t3list, siglist]
    if ( ( (group.ismember(g2)) == (False) ) ):
        output = False
    if ( ( (group.ismember(pklist)) == (False) ) ):
        output = False
    if ( ( (group.ismember(M)) == (False) ) ):
        output = False
    if ( ( (group.ismember(t1list)) == (False) ) ):
        output = False
    if ( ( (group.ismember(t2list)) == (False) ) ):
        output = False
    if ( ( (group.ismember(t3list)) == (False) ) ):
        output = False
    if ( ( (group.ismember(siglist)) == (False) ) ):
        output = False
    output = True
    return output

def dividenconquer(delta, startSigNum, endSigNum, incorrectIndices, dotACache, dotBCache, dotCCache, g2, pklist, M, t1list, t2list, t3list, siglist):

    input = [delta, startSigNum, endSigNum, incorrectIndices, dotACache, dotBCache, dotCCache, g2, pklist, M, t1list, t2list, t3list, siglist]
    dotALoopVal = 1
    dotBLoopVal = 1
    dotCLoopVal = 1
    for z in range(startSigNum, endSigNum):
        dotALoopVal = (dotALoopVal * dotACache[z])
        dotBLoopVal = (dotBLoopVal * dotBCache[z])
        dotCLoopVal = (dotCLoopVal * dotCCache[z])
    if ( ( (pair(dotALoopVal, g2)) == ((pair(a, dotBLoopVal) * pair(h, dotCLoopVal))) ) ):
        return
    else:
        midwayFloat = ((endSigNum - startSigNum) / 2)
        midway = int(midwayFloat)
    if ( ( (midway) == (0) ) ):
        incorrectIndices.append(startSigNum)
        output = None
    else:
        midSigNum = (startSigNum + midway)
        dividenconquer(delta, startSigNum, midway, incorrectIndices, dotACache, dotBCache, dotCCache, g2, pklist, M, t1list, t2list, t3list, siglist)
        dividenconquer(delta, midSigNum, endSigNum, incorrectIndices, dotACache, dotBCache, dotCCache, g2, pklist, M, t1list, t2list, t3list, siglist)
    output = None

def batchverify(g2, pklist, M, t1list, t2list, t3list, siglist, incorrectIndices):
    global a
    global b
    global h

    delta = {}
    dotCCache = {}
    dotBCache = {}
    dotACache = {}

    input = [g2, pklist, M, t1list, t2list, t3list, siglist, incorrectIndices]
    for z in range(0, N):
        delta[z] = SmallExp(secparam)
    if ( ( (membership(g2, pklist, M, t1list, t2list, t3list, siglist)) == (False) ) ):
        output = False
    for z in range(0, N):
        b = group.hash((M[z], t3list[z]), ZR)
        a = group.hash(t1list[z], G1)
        h = group.hash(t2list[z], G1)
        dotACache[z] = (siglist[z] ** delta[z])
        dotBCache[z] = (pklist[z] ** delta[z])
        dotCCache[z] = (pklist[z] ** (b * delta[z]))
    dividenconquer(delta, 0, N, incorrectIndices, dotACache, dotBCache, dotCCache, g2, pklist, M, t1list, t2list, t3list, siglist)
    output = incorrectIndices
    return output

def SmallExp(bits=80):
    return group.init(ZR, randomBits(bits))

def main():
    global group
    group = PairingGroup(secparam)


    g2 = setup()
    (pk0, sk0) = keygen(g2)
    (pk1, sk1) = keygen(g2)
    t1_0 = "1"
    t2_0 = "2"
    t3_0 = "3"
    t1_1 = "4"
    t2_1 = "5"
    t3_1 = "6"
    Mlist = ["mess1", "mess2"]
    sig0 = sign(pk0, sk0, Mlist[0], t1_0, t2_0, t3_0)
    sig1 = sign(pk1, sk1, Mlist[1], t1_1, t2_1, t3_1)
    #print(verify(pk0, g2, sig0, Mlist[0], t1, t2, t3))
    pklist = [pk0, pk1]
    M = Mlist
    t1list = [t1_0, t1_1]    
    t2list = [t2_0, t2_1]
    t3list = [t3_0, t3_1]
    siglist = [sig0, sig1]
    incorrectIndices = []
    batchverify(g2, pklist, M, t1list, t2list, t3list, siglist, incorrectIndices)
    print(incorrectIndices)





if __name__ == '__main__':
    main()

