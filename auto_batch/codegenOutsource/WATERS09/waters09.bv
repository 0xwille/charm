name := waters09
N := 2
setting := asymmetric

BEGIN :: types
 m := str
END :: types


verify := { (e(gb^s, sig1) * (e(gba1^s1, sig2) * (e(ga1^s1, sig3) * (e(gba2^s2, sig4) * e(ga2^s2, sig5))))) == (e(sig6, (tau1^s1) * (tau2^s2)) * (e(sig7, ((tau1b^s1) * ((tau2b^s2) * w^-t))) * ( ( ( e(sig7, ((u^(M * t)) * (w^(tagc * t))) * h^t) * (e(g1^-t, sigK)) )^theta) * (A^s2)))) }


BEGIN :: func:keygen
input := None
 g1 := random(G1)
 g2 := random(G2)
 a1 := random(ZR)
 a2 := random(ZR)
 b := random(ZR)
 alpha := random(ZR)
 wExp := random(ZR)
 hExp := random(ZR)
 vExp := random(ZR)
 v1Exp := random(ZR)
 v2Exp := random(ZR)
 u := random(ZR)

 vG1 := g1 ^ vExp
 v1G1 := g1 ^ v1Exp
 v2G1 := g1 ^ v2Exp

 vG2 := g2 ^ vExp
 v1G2 := g2 ^ v1Exp
 v2G2 := g2 ^ v2Exp

 wG1 := g1 ^ wExp
 hG1 := g1 ^ hExp
 wG2 := g2 ^ wExp
 hG2 := g2 ^ hExp

 uG1 := g1 ^ u
 uG2 := g2 ^ u

 tau1 := vG1 * (v1G1 ^ a1)
 tau2 := vG1 * (v2G1 ^ a2)

 g1b := g1 ^ b
 g1a1 := g1 ^ a1
 g1a2 := g1 ^ a2
 g1ba1 := g1 ^ (b * a1)
 g1ba2 := g1 ^ (b * a2)
 tau1b := tau1 ^ b
 tau2b := tau2 ^ b
 eggAlpha := (e(g1, g2)) ^ (alpha * a1 * b)
 
 g2AlphaA1 := g2 ^ (alpha * a1)
 g2b := g2 ^ b

 pk := list{g1, g2, g1b, g1a1, g1a2, g1ba1, g1ba2, tau1, tau2, tau1b, tau2b, uG1, uG2, wG1, hG1, wG2, hG2, eggAlpha}
 sk := list{g2AlphaA1, g2b, vG2, v1G2, v2G2, alpha}
 output := list{pk, sk}
END :: func:keygen

BEGIN :: func:sign
input := list{pk, sk, m}
 pk := expand{g1, g2, g1b, g1a1, g1a2, g1ba1, g1ba2, tau1, tau2, tau1b, tau2b, uG1, uG2, wG1, hG1, wG2, hG2, eggAlpha}
 sk := expand{g2AlphaA1, g2b, vG2, v1G2, v2G2, alpha}

 r1 := random(ZR)
 r2 := random(ZR)
 z1 := random(ZR)
 z2 := random(ZR)
 tagk := random(ZR)

 r := r1 + r2
 M := H(m, ZR)

 S#1 := g2AlphaA1 * (vG2 ^ r)
 S#2 := (g2 ^ -alpha) * (v1G2 ^ r) * (g2 ^ z1)
 S#3 := g2b ^ -z1
 S#4 := (v2G2 ^ r) * (g2 ^ z2)
 S#5 := g2b ^ -z2
 S#6 := g2b ^ r2
 S#7 := g2 ^ r1
 SK := ((uG2 ^ M) * (wG2 ^ tagk) * (hG2) ^ r1

 output := list{S, SK, tagk}
END :: func:sign

BEGIN :: func:verify
input := list{pk, S, SK, tagk, m}
 s1 := random(ZR)
 s2 := random(ZR)
 t := random(ZR)
 tagc := random(ZR)

 s := s1 + s2
 M := H(m, ZR)

 E1 := ((pk#11 ^ M) * (pk#13 ^ tagc) * pk#14) ^ t
 E2 := pk#0 ^ t
 A := (pk#17 ^ s2)
 theta := (1 / (tagc - tagk))

# lhs_pair := e(pk#2 ^ s, S#1) * e(pk#5 ^ s1, S#2) * e(pk#3 ^ s1, S#3) * e(pk#6 ^ s2, S#4) * e(pk#4 ^ s2, S#5)
# rhs_pair := e((pk#7 ^ s1) * (pk#8 ^ s2), S#6) * e((pk#9 ^ s1) * (pk#10 ^ s2) * (pk#13 ^ -t), S#7) * ((e(E1, S#7) / e(E2, SK)) ^ theta) * A

BEGIN :: if
if { (e(gb^s, sig1) * (e(gba1^s1, sig2) * (e(ga1^s1, sig3) * (e(gba2^s2, sig4) * e(ga2^s2, sig5))))) == (e(sig6, (tau1^s1) * (tau2^s2)) * (e(sig7, ((tau1b^s1) * ((tau2b^s2) * w^-t))) * ( ( ( e(sig7, ((u^(M * t)) * (w^(tagc * t))) * h^t) * (e(g1^-t, sigK)) )^theta) * (A^s2)))) }
   output := True
else
   output := False
END :: if
END :: func:verify


