name := cyh
setting := asymmetric
N := 100
l := 3
secparam := 80

BEGIN :: types
M := str
ID := str
L := list{str}
u := list{G1}
h := list{ZR}
s := int
pkList := list{G1}
pk := G1
sk := G1
P := G2
S := G1
g := G2
r := ZR
END :: types

BEGIN :: precompute
h := H(M | L | u, ZR)
END :: precompute

constant := list{P, g}
public := pk
signature := list{S, u}
message := h

BEGIN :: count
message_count := N
public_count := l
signature_count := N
END :: count

verify := { e((prod{y:=0, l} on (u_y * (pkList_y^h_y))) , P) == e(S, g) }

BEGIN :: func:setup
 input := None
 g := random(G2)
 alpha := random(ZR)
 P := g ^ alpha
 output := list{P, g, alpha}
END :: func:setup

BEGIN :: func:concat
 input := ID_List
 L := init(str)
 l := len(ID_List)
BEGIN :: for
for{y := 0, l}
 L := (L | ID_List#y)
END :: for
output := L
END :: func:concat

BEGIN :: func:keygen
 input := list{alpha, ID}
 sk := H(ID, G1) ^ alpha
 pk := H(ID, G1)
 output := list{pk, sk}
END :: func:keygen

BEGIN :: func:sign
 input := list{ID, pk, sk, L, M}
 Lt := concat(L)

BEGIN :: for
for{i := 0, l}
BEGIN :: if
 if { ID != L#i }
    u#i := random(G1)
    h#i := H(M | Lt | u#i, ZR)
 else
    s := i
END :: if
END :: for

 r := random(ZR)
BEGIN :: for
for{y := 0, l}
   pkList#y := H(L#y, G1)
END :: for

dotProd := init(G1)

BEGIN :: for
for{i := 0, l}
BEGIN :: if
if {ID != L#i}
   dotProd := dotProd * (u#i * (pkList#i ^ h#i))
END :: if
END :: for

  u#s? := (pk ^ r) * dotProd
  h#s? := H(M | Lt | u#s, ZR)
  S := sk ^ (h#s + r)
output := list{u, S}
END :: func:sign

BEGIN :: func:verify
input := list{P, g, L, M, u, S}
 Lt := concat(L)
 num_sign := len(L)

# h := init(ZR)
BEGIN :: for
for{y := 0, l}
 h#y := H(M | Lt | u#y, ZR)
 pkList#y := H(L#y, G1)
END :: for

dotProd := init(G1)

BEGIN :: for
for{y := 0, l}
   dotProd := dotProd * (u#y * (pkList#y ^ h#y))
END :: for

BEGIN :: if
if {e(dotProd, P) == e(S, g)}
   output := True
else
   output := False
END :: if
END :: func:verify


