name := waters05
N := 100
l := 5
setting := asymmetric

BEGIN :: types
alpha := ZR
m := ZR
k := ZR
S1 := G1
S2 := G1
S3 := G1
h := G1
ub := G2
u1b := G2
u2b := G2
g2 := G2
A := GT
END :: types

BEGIN :: precompute
A := e(h, g2)^alpha
END :: precompute

constant := list{A, g2, ub, u1b, u2b}
public := k
signature := list{S1, S2, S3}
message := m

BEGIN :: count
message_count := N
public_count := N
signature_count := N
END :: count

BEGIN :: func:setup
input := list{zz, ll}
 alpha := random(ZR) 
 h := random(G1)
 g1 := random(G1)
 g2 := random(G2)
 A := (e(h, g2) ^ alpha)

BEGIN :: for
for{i := 0, zz}
 y#i := random(ZR)
 u#i := g1 ^ y#i
 ub#i := g2 ^ y#i
END :: for

 y1t := random(ZR)
 y2t := random(ZR)

 u1t := g1 ^ y1t
 u2t := g1 ^ y2t

 u1b := g2 ^ y1t
 u2b := g2 ^ y2t

 msk := h ^ alpha
 mpk := list{g1, g2, A, u1t, u2t, u, u1b, u2b, ub, zz, ll} 
output := list{mpk, msk}
END :: func:setup

BEGIN :: func:keygen
input := list{mpk, msk, ID}
 mpk := expand{g1, g2, A, u1t, u2t, u, u1b, u2b, ub, zz, ll}
 
 k := stringToInt(ID, zz, ll)
 
BEGIN :: for
for{i := 0, zz}
 dotProd = dotProd * (u#i ^ k#i)
END :: for

 r := group.random(ZR)
 k1 := msk * ((u1t * dotProd) ^ r)
 k2 := g1 ^ -r
 output := list{k1, k2}
END :: func:keygen



BEGIN :: func:sign
input := list{mpk, sk, M}
 mpk := expand{g1, g2, A, u1t, u2t, u, u1b, u2b, ub, zz, ll}
 m := stringToID(M, zz, ll)
 sk := expand{k1, k2}
 s  := group.random(ZR)
BEGIN :: for
for{i := 0, zz}
 dotProd := dotProd * (u#i * m#i)
END :: for

 S1 := k1 * ((u2t * dotProd) ^ s)
 S2 := k2
 S3 := g1 ^ -s
output := list{S1, S2, S3}
END :: func:sign

BEGIN :: func:verify
 input := list{A, g2, ub, u1b, u2b, ID, M, S1, S2, S3}

kver := stringToInt(ID, zz, ll)
mver := stringToInt(M, zz, ll)

BEGIN :: for
for{i := 0, zz}
  dotProd1 = dotProd1 * (ub#i ^ kver#i)
  dotProd2 = dotProd2 * (ub#i ^ mver#i)
END :: for

BEGIN :: if
if { ((pair(S1, g2) * pair(S2, u1b * dotProd1) * pair(S3, u2b * dotProd2)) == A) }
   output := True
else
   output := False
END :: if
END :: func:verify
