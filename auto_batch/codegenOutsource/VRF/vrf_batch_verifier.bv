name := vrf
N := 100
setting := asymmetric
l := 4 
secparam := 80

# pi#0 := G1
# pi#1 := G1
# pi#n := G1
# pi#t := G1
# pi#t-1 := G1 
# x#0 := ZR
# x#t := ZR
# U1#0 := G1 
# U2#0 := G2
# U2#t := G2

BEGIN :: types
pi0 := G1
pi := list{G1}
g1 := G1
g2 := G2
x := list{int}
Ut := G2
U1 := list{G1}
U2 := list{G2}
y0 := GT
h := G2
ut := ZR
u := list{ZR}
result0 := GT
delta1 := list{ZR}
delta2 := list{ZR}
delta3 := list{ZR}
startSigNum := int
endSigNum := int
incorrectIndices := list{int}
dotCLoopVal := G1
dotDLoopVal := G1
dotELoopVal := GT
dotFLoopVal := G1
dotGLoopVal := G1
dotHLoopVal := G1
dotALoopVal := G1
dotBLoopVal := G1
dotFCache := list{G1}
dotECache := list{GT}
dotHCache := list{G1}
dotGCache := list{G1}
dotBCache := list{G1}
dotACache := list{G1}
dotDCache := list{G1}
dotCCache := list{G1}
pilink := list{G1}
y0list := list{GT}
pilist := list{pilink}
xlink := list{int}
xlist := list{xlink}
END :: types

constant := list{g1, g2, h}
message := list{x#0?, x#t?}
public := list{U1, U2, U1#0?, U2#0?, U2#t?, Ut}
signature := list{pi0?, pi#0?, pi#1?, pi#l-1?, pi#t?, pi#t-1?, y0}

# same signer
BEGIN :: count
message_count := N
public_count := one
signature_count := N
END :: count

#2, 6, 5, 3, 2
#transform := list{2, 3, 5, 3, 6}

verify1 := { e(pi#1?, g2) == e((g1^(1 - x#0?)) * (U1#0?^x#0?), Ut) } and {{ e(pi#0?, g2) == e(pi#l?, U2#0?) } and { e(pi#0?, h) == y0 }}

# l + 1
BEGIN :: for
for{t := 2, 5}
verify2 := { e(pi#t?, g2) == (e((pi#t-1?^(1 - x#t-1?)), g2) * e(pi#t-1?^x#t-1?, U2#t-1?)) }
END :: for


BEGIN :: func:setup
input := list{n}
g1 := random(G1)
g2 := random(G2)
h := random(G2)
ut := random(ZR)
Ut := g2 ^ ut

BEGIN :: for
for{i := 0, n+1}
u#i := random(ZR)
END :: for

BEGIN :: for
for{i := 0, n}
U1#i := g1 ^ u#i
U2#i := g2 ^ u#i
END :: for

pk := list{Ut, g1, g2, h}
sk := list{ut, g1, h}
output := list{pk, U1, U2, sk, u}
END :: func:setup



BEGIN :: func:polyF
input := list{sk, u, x}

sk := expand{ut, g1, h}

dotProd := init(ZR)
BEGIN :: for
for{i:= 0, l}
dotProd := dotProd * (u#i ^ x#i)
END :: for

result0 := e((g1 ^ ((ut * u#0) * dotProd)), h)

output := result0
END :: func:polyF



BEGIN :: func:prove
input := list{sk, u, x}

sk := expand{ut, g1, h}

BEGIN :: for
for{i := 0, l}
dotProd0 := init(ZR)
BEGIN :: forinner
forinner{j := 0, i+1}
   dotProd0 := dotProd0 * (u#j ^ x#j)
END :: forinner
pi#i+1? := g1 ^ (ut * dotProd0)
END :: for

dotProd1 := init(ZR)
BEGIN :: for
for{i := 0, l}
   dotProd1 := dotProd1 * (u#i ^ x#i)
END :: for
pi#0 := g1 ^ (ut * u#0 * dotProd1)
y0 := polyF(sk, u, x)
output := list{y0, pi}
END :: func:prove


BEGIN :: func:verify
input := list{U1, U2, Ut, g1, g2, h, y0, pi, x}

proof0 := e(pi#1?, g2)

BEGIN :: if
if { { x#0? == 0} and {proof0 != e(g1, Ut)} }
   output := False
END :: if

BEGIN :: if
if { { x#0? == 1} and {proof0 != e(U1#0, Ut) } }
   output := False
END :: if

BEGIN :: if
if { { x#0? != 0 } and { x#0? != 1 } }
   output := False
END :: if 

BEGIN :: for
for{i := 2, l+1}

proof1 := e(pi#i?, g2)
BEGIN :: if
if { { x#i-1? == 0 } and { proof1 != e(pi#i-1?, g2) } }
   output := False
END :: if

BEGIN :: if
if { { x#i-1? == 1 } and { proof1 != e(pi#i-1?, U2#i-1?) } } 
   output := False
END :: if

BEGIN :: if
if { { x#i-1? != 0 } and { x#i-1? != 1 } }
   output := False
END :: if 
END :: for

BEGIN :: if
if { e(pi#0, g2 * h) != (e(pi#l?, U2#0?) * y0) }
   output := False
END :: if

output := True
END :: func:verify


BEGIN :: latex
pi0? := \pi_0
pi#0? := \pi_1
pi#1? := \pi_1
pi#l-1? := \pi_{l-1}
pi#t? := \pi_t
pi#t-1? := \pi_{t-1}
g1 := g_1
g2 := g_2
x#0? := x_1
x#t? := x_t
Ut := \hat{U}
U1#0? := U_1
U2#0? := U_0
U2#t? := U_t
END :: latex

BEGIN :: func:membership
 input := list{U1, U2, Ut, g1, g2, h, pilist, xlist, y0list}


BEGIN :: if
if { ismember(U1) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(U2) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(Ut) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(g1) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(g2) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(h) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(pilist) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(xlist) == False }
    output := False
END :: if

BEGIN :: if
if { ismember(y0list) == False }
    output := False
END :: if

 output := True
END :: func:membership


BEGIN :: func:dividenconquer
 input := list{delta1, delta3, delta2, startSigNum, endSigNum, incorrectIndices, dotACache, dotBCache, dotCCache, dotDCache, dotECache, dotFCache, dotGCache, dotHCache, Ut, g2, U2, h}
dotALoopVal := init(G1)
dotBLoopVal := init(G1)
dotCLoopVal := init(G1)
dotDLoopVal := init(G1)
dotELoopVal := init(GT)
dotFLoopVal := init(G1)
dotGLoopVal := init(G1)
dotHLoopVal := init(G1)

BEGIN :: for
for{z := startSigNum, endSigNum}
dotALoopVal := dotALoopVal * dotACache#z
dotBLoopVal := dotBLoopVal * dotBCache#z
dotCLoopVal := dotCLoopVal * dotCCache#z
dotDLoopVal := dotDLoopVal * dotDCache#z
dotELoopVal := dotELoopVal * dotECache#z
dotFLoopVal := dotFLoopVal * dotFCache#z
dotGLoopVal := dotGLoopVal * dotGCache#z
dotHLoopVal := dotHLoopVal * dotHCache#z
END :: for
BEGIN :: if
 if { (e(dotALoopVal,Ut) * e(dotBLoopVal,g2)) == ((e(dotCLoopVal,U2#0?) * (e(dotDLoopVal,(g2 * h)) * dotELoopVal)) * ((e(dotFLoopVal,U2#1?)^-1) * (e(dotGLoopVal,U2#2?) * e(dotHLoopVal,U2#3?)))) }
    return := None
 else
    midwayFloat := ((endSigNum - startSigNum) / 2)
    midway := integer(midwayFloat)
END :: if


BEGIN :: if
 if { midway == 0 } 
    addToList(incorrectIndices, startSigNum)
    output := None
 else
    midSigNum := startSigNum + midway
    dividenconquer(delta1, delta3, delta2, startSigNum, midway, incorrectIndices, dotACache, dotBCache, dotCCache, dotDCache, dotECache, dotFCache, dotGCache, dotHCache, Ut, g2, U2, h)
    dividenconquer(delta1, delta3, delta2, midSigNum, endSigNum, incorrectIndices, dotACache, dotBCache, dotCCache, dotDCache, dotECache, dotFCache, dotGCache, dotHCache, Ut, g2, U2, h)
END :: if


 output := None
END ::func:dividenconquer


BEGIN :: func:batchverify
input := list{U1, U2, Ut, g1, g2, h, pilist, xlist, y0list, incorrectIndices}

BEGIN :: for
for{z := 0, N}
 delta1#z := SmallExp(secparam)
delta3#z := SmallExp(secparam)
delta2#z := SmallExp(secparam)
END :: for

BEGIN :: if
 if {(membership(U1, U2, Ut, g1, g2, h, pilist, xlist, y0list) == False)}
     output := False
END :: if


BEGIN :: for
for{z := 0, N}
dotACache#z := ((g1^((1 - xlist#z#0?) * delta1#z)) * (U1#0?^(xlist#z#0? * delta1#z)))
dotBCache#z := ((pilist#z#1?^-delta1#z) * ((pilist#z#2?^-delta#z) * ((pilist#z#1?^(((1 - xlist#z#1?) * -delta#z) * -1)) * ((((pilist#z#3?^delta#z) * (pilist#z#2?^((1 - xlist#z#2?) * -delta#z)))^-1) * (((pilist#z#4?^delta#z) * (pilist#z#3?^((1 - xlist#z#3?) * -delta#z)))^-1)))))
dotCCache#z := (pilist#z#l?^delta2#z)
dotDCache#z := (pilist#z#0?^-delta2#z)
dotECache#z := (y0list#z^-delta3#z)
dotFCache#z := (pilist#z#1?^(xlist#z#1? * delta#z))
dotGCache#z := (pilist#z#2?^(xlist#z#2? * delta#z))
dotHCache#z := (pilist#z#3?^(xlist#z#3? * delta#z))
END :: for
 dividenconquer(delta1, delta3, delta2, 0, N, incorrectIndices, dotACache, dotBCache, dotCCache, dotDCache, dotECache, dotFCache, dotGCache, dotHCache, Ut, g2, U2, h)

 output := incorrectIndices
END ::func:batchverify


