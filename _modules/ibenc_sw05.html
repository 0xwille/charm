

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ibenc_sw05 &mdash; Charm-Crypto 0.4b documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.4b',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Charm-Crypto 0.4b documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Charm-Crypto 0.4b documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for ibenc_sw05</h1><pre>

| From: "A. Sahai, B. Waters Fuzzy Identity-Based Encryption.
| Published in: Eurocrypt 2005
| Available from: eprint.iacr.org/2004/086.pdf
| Notes: Original construction (Section 4) and large universe construction (Section 6). 

* type:            encryption (identity-based)
* setting:        bilinear groups

:Authors:    Christina Garman
:Date:       10/2011
'''

from toolbox.pairinggroup import *
from charm.cryptobase import *
from toolbox.IBEnc import *
from charm.pairing import hash as sha1
from toolbox.secretshare import *
import sys

debug = False
class IBE_SW05(IBEnc):    
    def __init__(self, groupObj):
<div class="viewcode-block" id="IBE_SW05"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05">[docs]</a>        IBEnc.__init__(self)
        global group, H, util
        group = groupObj
        H = lambda x: group.hash(('0', x), ZR)
        util = SecretShare(group, False)
        
    def setup(self, n, d):
        '''
<div class="viewcode-block" id="IBE_SW05.setup"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05.setup">[docs]</a>        :Parameters:
           - ``n``: the maximum number of attributes in the system.
                    OR the maximum length of an identity
           - ``d``: the set overlap required to decrypt
        '''
        g = group.random(G1)
        y = group.random(ZR)
        Y = pair(g, g) ** y

        t = [ group.random(ZR) for x in range( n )]
        T = [ g ** i for i in t]
        
        pk = { 'g':g, 'Y':Y, 'T': T } 
        mk = { 'y':y, 't':t }         # master secret
        return (pk, mk)

    def intersection_subset(self, w, wPrime, d):
        S = []</div>
<div class="viewcode-block" id="IBE_SW05.intersection_subset"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05.intersection_subset">[docs]</a>        for i in range(len(w)):
            for j in range(len(wPrime)):
                if(w[i] == wPrime[j]):
                    S.append(w[i])

        if(len(S) &lt; d):
            assert False, "Cannot decrypt.  w and w' do not have enough attributes in common."

        S_sub  = [S[k] for k in range(d)]
        return S_sub
    
    def extract(self, mk, ID, pk, dOver, n):
        w_hash = [H(x) for x in ID] # assumes ID is a list</div>
<div class="viewcode-block" id="IBE_SW05.extract"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05.extract">[docs]</a>
        #a d-1 degree polynomial q is generated such that q(0) = y
        q = [group.random(ZR) for x in range(dOver)]
        q[0] = mk['y']
        # use secret sharing as building block
        shares = util.genShares(mk['y'], dOver, n, q, w_hash)
        D = {}; t_index = {};
        for i in w_hash:       
            j = w_hash.index(i)
            D[i] = (pk['g'] ** (shares[j][1] / mk['t'][j]))
            # dictionary for finding corresponding T public value when encrypting 
            # this eliminates ordering of attribute issues
            t_index[i] = j; 
            
        pk['T_index'] = t_index
        return (w_hash, { 'D':D })

    def encrypt(self, pk, w_prime, M, n):
        '''       </div>
<div class="viewcode-block" id="IBE_SW05.encrypt"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05.encrypt">[docs]</a>        Encryption with the public key, Wprime and the message M in G2
        '''
        w_prime_hash = [H(x) for x in w_prime]
        s = group.random(ZR)

        Eprime = M * (pk['Y'] ** s)
        E = {}
        for i in w_prime_hash:
            k = pk['T_index'][i]
            E[i] = pk['T'][k] ** s

        return { 'wPrime':w_prime_hash, 'Eprime':Eprime, 'E':E}

    def decrypt(self, pk, sk, CT, w, d):
        '''dID must have an intersection overlap of at least d with Wprime to decrypt</div>
<div class="viewcode-block" id="IBE_SW05.decrypt"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05.decrypt">[docs]</a>        '''
        S = self.intersection_subset(w, CT['wPrime'], d)
        coeffs = util.recoverCoefficients(S)
        prod = 1
        for i in S:            
            prod *= pair(sk['D'][i], CT['E'][i]) ** coeffs[i]
            
        return CT['Eprime'] / prod
 

'''
Sahai-Waters Fuzzy Identity-Based Encryption, Large Universe Construction</div></div>

| From: "A. Sahai, B. Waters Fuzzy Identity-Based Encryption.
| Published in: Eurocrypt 2005
| Available from: eprint.iacr.org/2004/086.pdf
| Notes: Original construction (Section 4) and large universe construction (Section 6). 

* type:            encryption (identity-based)
* setting:        bilinear groups

:Authors:    Christina Garman
:Date:       10/2011
'''
class IBE_SW05_LUC(IBEnc):    
    def __init__(self, groupObj):
<div class="viewcode-block" id="IBE_SW05_LUC"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05_LUC">[docs]</a>        IBEnc.__init__(self)
        global group, H, util
        group = groupObj
        H = lambda x: group.hash(('0', x), ZR)
        util = SecretShare(group, False)
        
    def setup(self, n, d):
        '''
<div class="viewcode-block" id="IBE_SW05_LUC.setup"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05_LUC.setup">[docs]</a>        :Parameters:
           - ``n``: the maximum number of attributes in the system.
                    OR the maximum length of an identity
           - ``d``: the set overlap required to decrypt
        '''
        g = group.random(G1)
        y = group.random(ZR)
        g1 = g ** y
        g2 = group.random(G1)
        
        t = [ group.random(G1) for x in range( n+1 )]
        
        pk = { 'g':g, 'g1':g1, 'g2':g2, 't':t } 
        mk = { 'y':y }         # master secret
        return (pk, mk)

    def eval_T(self, pk, n, x):
        N = [group.init(ZR,(x + 1)) for x in range(n + 1)]        </div>
<div class="viewcode-block" id="IBE_SW05_LUC.eval_T"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05_LUC.eval_T">[docs]</a>        N_int = [(x + 1) for x in range(n + 1)]
        
        coeffs = util.recoverCoefficients(N)
        prod_result = 1
        for i in N_int:
            j = group.init(ZR, i)
            prod_result *= (pk['t'][i-1] ** coeffs[j])
        
        T = (pk['g2'] ** (x * n)) * prod_result
        return T

    def intersection_subset(self, w, wPrime, d):
        S = []</div>
<div class="viewcode-block" id="IBE_SW05_LUC.intersection_subset"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05_LUC.intersection_subset">[docs]</a>        for i in range(len(w)):
            for j in range(len(wPrime)):
                if(w[i] == wPrime[j]):
                    S.append(w[i])

        if(len(S) &lt; d):
            assert False, "Cannot decrypt.  w and w' do not have enough attributes in common."

        S_sub  = [S[k] for k in range(d)]
        return S_sub
    
    def extract(self, mk, ID, pk, dOver, n):
        w_hash = [H(x) for x in ID] # assumes ID is a list</div>
<div class="viewcode-block" id="IBE_SW05_LUC.extract"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05_LUC.extract">[docs]</a>
        r = group.random(ZR)
        #a d-1 degree polynomial q is generated such that q(0) = y
        q = [group.random(ZR) for x in range(dOver)]
        q[0] = mk['y']
        shares = util.genShares(mk['y'], dOver, n, q, w_hash)
        D = {}
        d = {}
        for i in w_hash:       
            j = w_hash.index(i)
            D[i] = (pk['g2'] ** shares[j][1]) * (self.eval_T(pk, n, i) ** r)
            d[i] = pk['g'] ** r

        return (w_hash, { 'D':D, 'd':d })

    def encrypt(self, pk, w_prime, M, n):
        '''       </div>
<div class="viewcode-block" id="IBE_SW05_LUC.encrypt"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05_LUC.encrypt">[docs]</a>        Encryption with the public key, Wprime and the message M in G2
        '''
        w_prime_hash = [H(x) for x in w_prime]
        s = group.random(ZR)

        Eprime = M * (pair(pk['g1'], pk['g2']) ** s)
        Eprimeprime = pk['g'] ** s
        
        E = {}
        for i in w_prime_hash:
            E[i] = self.eval_T(pk, n, i) ** s

        return { 'wPrime':w_prime_hash, 'Eprime':Eprime, 'Eprimeprime':Eprimeprime,'E':E}

    def decrypt(self, pk, sk, CT, w, d):
        '''dID must have an intersection overlap of at least d with Wprime to decrypt</div>
<div class="viewcode-block" id="IBE_SW05_LUC.decrypt"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.IBE_SW05_LUC.decrypt">[docs]</a>        '''
        S = self.intersection_subset(w, CT['wPrime'], d)
        #print("S :=", S)
        coeffs = util.recoverCoefficients(S)
        prod = 1
        for i in S:
            prod *= (pair(sk['d'][i], CT['E'][i]) / pair(sk['D'][i], CT['Eprimeprime'])) ** coeffs[i]
            
        return CT['Eprime'] * prod


 
        
def main():
    # initialize the element object so that object references have global scope</div></div>
<div class="viewcode-block" id="main"><a class="viewcode-back" href="../schemes/ibenc_sw05.html#ibenc_sw05.main">[docs]</a>    groupObj = PairingGroup('SS512')
    n = 6; d = 4
    ibe = IBE_SW05_LUC(groupObj)
    (pk, mk) = ibe.setup(n, d)
    if debug:
        print("Parameter Setup...")
        print("pk =&gt;", pk)
        print("mk =&gt;", mk)

    w = ['insurance', 'id=2345', 'oncology', 'doctor', 'nurse', 'JHU'] #private identity
    wPrime = ['insurance', 'id=2345', 'doctor', 'oncology', 'JHU', 'billing', 'misc'] #public identity for encrypt

    (w_hashed, sk) = ibe.extract(mk, w, pk, d, n)

    M = groupObj.random(GT)
    cipher = ibe.encrypt(pk, wPrime, M, n)
    m = ibe.decrypt(pk, sk, cipher, w_hashed, d)

    assert m == M, "FAILED Decryption: \nrecovered m = %s and original m = %s" % (m, M)
    if debug: print("Successful Decryption!! M =&gt; '%s'" % m)
                
if __name__ == '__main__':
    debug = True</div>
    main()
</pre>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Charm-Crypto 0.4b documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Johns Hopkins University ISI.
      Last updated on Feb 19, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1pre.
    </div>
  </body>
</html>